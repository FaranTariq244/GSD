#progress Log

## Learnings
- Database: PostgreSQL with pg client library
- Migration pattern: Custom SQL migration runner in src/migrate.ts
- Database connection: Pool exported as default from src/db.ts, configured via environment variables
- Migration files stored in packages/backend/migrations/ as .sql files
- Run migrations with: npm run migrate (in backend package)
- Database config: .env.example provides template for DB_HOST, DB_PORT, DB_NAME, DB_USER, DB_PASSWORD
- Authentication: JWT tokens stored in httpOnly cookies (7 day expiration)
- Auth middleware: authenticate function in src/middleware/auth.ts adds userId to request
- Password hashing: bcryptjs with salt rounds = 10
- JWT_SECRET: Required in .env for production, defaults to dev-secret in development

---

## Iteration 1 - Set up project structure
- Created monorepo using npm workspaces with packages/backend and packages/frontend
- Backend: Node.js + TypeScript + Express with basic health endpoint
- Frontend: Vite + React 19 + TypeScript (scaffolded with create-vite)
- Files changed:
  - Root: package.json (workspace config), .gitignore, README.md, PRD.md (added task checklist)
  - Backend: package.json, tsconfig.json, src/index.ts
  - Frontend: All Vite scaffolded files (updated package.json name to @gsd/frontend)
- Learnings for future iterations:
  - Project uses npm workspaces for monorepo structure
  - Backend runs on port 3000 by default
  - Frontend runs on port 5173 (Vite default)
  - Test command returns exit 0 for now (no tests yet)
  - Typecheck uses `tsc --noEmit` across both packages
  - PRD.md now has task checklist at the top (added in this iteration)
---

## Iteration 2 - Set up database schema and migrations
- Installed pg and @types/pg for PostgreSQL database client
- Created comprehensive database schema covering all tables from PRD data model
- Files changed:
  - packages/backend/package.json (added pg, node-pg-migrate, @types/pg, and migrate script)
  - packages/backend/migrations/1_initial_schema.sql (all 8 tables with indexes)
  - packages/backend/src/db.ts (pool connection with env config)
  - packages/backend/src/migrate.ts (custom migration runner)
  - packages/backend/.env.example (database and server config template)
- Learnings for future iterations:
  - Tables: users, accounts, account_members, boards, tasks, task_assignees, task_tags, comments, attachments
  - All tables follow PRD spec with proper foreign keys and cascade deletes
  - Migration runner tracks applied migrations in a migrations table
  - Migration runner uses transactions (BEGIN/COMMIT/ROLLBACK) for safety
  - Indexes added for common query patterns (board_id, column, task_id, user_id, tag)
  - Database can be initialized by running: npm run migrate (in backend package)
---

## Iteration 3 - Implement user signup/login authentication
- Installed bcryptjs, jsonwebtoken, and cookie-parser with type definitions
- Created authentication middleware (src/middleware/auth.ts) that validates JWT tokens from cookies
- Created auth routes (src/routes/auth.ts) with three endpoints:
  - POST /auth/signup: Creates user with hashed password, returns JWT in httpOnly cookie
  - POST /auth/login: Validates credentials, returns JWT in httpOnly cookie
  - POST /auth/logout: Clears authentication cookie
- Files changed:
  - packages/backend/package.json (added bcryptjs, jsonwebtoken, cookie-parser + types)
  - packages/backend/src/index.ts (added cookie-parser middleware and auth routes)
  - packages/backend/src/middleware/auth.ts (JWT authentication middleware)
  - packages/backend/src/routes/auth.ts (signup, login, logout endpoints)
  - packages/backend/.env.example (added JWT_SECRET)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Auth uses JWT tokens stored in httpOnly cookies (secure, sameSite: lax)
  - Token expiration: 7 days
  - Password validation: minimum 8 characters
  - Email addresses are lowercased for consistent lookups
  - AuthRequest interface extends Express Request to add userId field
  - Import pattern: pool is exported as default from db.ts (use `import pool from '../db.js'`)
  - 401 responses for auth failures, 400 for validation errors, 500 for server errors
---

## Iteration 4 - Implement GET /me endpoint
- Added GET /me endpoint to retrieve current authenticated user information
- Endpoint uses authenticate middleware to verify JWT token from cookie
- Returns user object with id, name, email, and created_at (excludes password_hash)
- Files changed:
  - packages/backend/src/routes/auth.ts (added GET /me endpoint)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - GET /me endpoint pattern: Use authenticate middleware, query user by req.userId
  - Endpoint returns 404 if user not found, 500 for server errors
  - Response format matches signup/login: { user: { id, name, email, created_at } }
---

## Iteration 5 - Create account automatically on signup with single board
- Modified POST /auth/signup to create account, add user as owner, and create board in single transaction
- Uses database transaction (BEGIN/COMMIT/ROLLBACK) to ensure atomicity
- Creates account with name format: "{user_name}'s Team"
- Adds user to account_members table with role 'owner'
- Creates default board named "Team Board"
- Files changed:
  - packages/backend/src/routes/auth.ts (wrapped signup logic in transaction, added account/board creation)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Use pool.connect() to get a client for transactions
  - Transaction pattern: BEGIN -> operations -> COMMIT/ROLLBACK -> finally release()
  - Account creation automatically creates: account -> account_members (owner) -> board
  - Default naming: "{user_name}'s Team" for account, "Team Board" for board
  - Always release database client in finally block
---

## Iteration 6 - Implement member invite system
- Created invites table migration to store invite tokens with email, account, and expiration
- Created POST /account/invite endpoint that generates secure invite tokens
- Endpoint validates user is a member of an account before allowing invites
- Prevents duplicate invites for same email to same account
- Prevents inviting users who are already members
- Generates secure random 32-byte hex token using crypto.randomBytes
- Invites expire after 7 days
- Files changed:
  - packages/backend/migrations/2_add_invites_table.sql (new migration)
  - packages/backend/src/routes/account.ts (new file with invite endpoint)
  - packages/backend/src/index.ts (registered account routes)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Invite system uses invites table with token, email, account_id, invited_by, expires_at, used_at
  - Token generation: crypto.randomBytes(32).toString('hex') for secure random tokens
  - Invite expiration: 7 days from creation (matches JWT token expiration)
  - Validation checks: user is member, target not already member, no active invite exists
  - Email normalization: lowercase and trim before storing/comparing
  - Returns invite object with id, email, token, created_at, expires_at
---

## Iteration 7 - Implement join flow for invited members
- Created POST /account/join endpoint that allows users to accept invites and join accounts
- Endpoint validates invite token (exists, not used, not expired)
- Verifies authenticated user's email matches invite email
- Adds user to account_members table with role 'member'
- Marks invite as used by setting used_at timestamp
- Returns account details after successful join
- Files changed:
  - packages/backend/src/routes/account.ts (added /account/join endpoint)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Join flow pattern: validate token -> check expiry/used status -> verify email match -> add to account -> mark invite used
  - Uses database transaction for atomicity (BEGIN/COMMIT/ROLLBACK)
  - Email verification: user's email must match invite email (case-insensitive comparison)
  - Prevents duplicate membership: checks if user is already a member before adding
  - HTTP status codes: 404 for invalid token, 400 for used/expired/duplicate, 403 for email mismatch
  - Transaction includes: check invite, check user, add member, mark invite used, get account details
---

## Iteration 8 - Implement GET /board endpoint
- Created GET /board endpoint that returns the single board for the authenticated user's account
- Endpoint uses authenticate middleware and joins boards with account_members to verify user access
- Returns board object with id, account_id, name, and created_at
- Files changed:
  - packages/backend/src/routes/board.ts (new file with GET /board endpoint)
  - packages/backend/src/index.ts (registered board routes)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Board endpoint pattern: Join boards with account_members using user_id to get user's board
  - Each account has exactly one board (enforced by UNIQUE constraint on account_id in boards table)
  - Query uses INNER JOIN to ensure user is a member of the account before returning board
  - HTTP status codes: 404 if no board found, 500 for server errors
  - Response format: { board: { id, account_id, name, created_at } }
---

## Iteration 9 - Implement task CRUD endpoints
- Created GET /tasks endpoint with support for query filters (column, assignee, tag, search)
- Created POST /tasks endpoint that creates tasks with default column 'inbox' and default priority 'normal'
- Created PATCH /tasks/:id endpoint that updates task fields, assignees, and tags
- Created DELETE /tasks/:id endpoint that deletes tasks with cascade to assignees, tags, comments, attachments
- Files changed:
  - packages/backend/src/routes/tasks.ts (new file with all 4 endpoints)
  - packages/backend/src/index.ts (registered tasks routes)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Valid columns: 'goals', 'inbox', 'today', 'wait', 'finished', 'someday'
  - Valid priorities: 'hot', 'warm', 'normal', 'cold'
  - Tasks support: title (required), description, tags (array), priority, due_date, assignee_ids (array)
  - POST /tasks automatically calculates next position in column (max + 1)
  - GET /tasks returns tasks with nested assignees and tags arrays
  - All endpoints verify user access via board membership (joins with account_members)
  - PATCH /tasks replaces assignees and tags completely (delete then insert)
  - DELETE /tasks cascades to task_assignees, task_tags, comments, attachments (DB foreign keys)
  - Filter patterns: column (exact match), assignee (EXISTS subquery), tag (EXISTS subquery), search (ILIKE for title)
  - Task response format includes: id, board_id, title, description, column, position, priority, due_date, assignees[], tags[], created_by, created_at, updated_at
---
## Iteration 10 - Build board columns UI component
- Created Board.tsx component displaying 6 fixed columns with proper layout
- Integrated task fetching from backend API using fetch with credentials
- Added column headers with task counts and max limit indicator (Today shows X/3)
- Created Board.css with clean, modern styling (flex-based column layout)
- Updated App.tsx to render Board component instead of default Vite template
- Cleaned up App.css and index.css for proper full-page board layout
- Added API proxy in vite.config.ts to forward /api requests to backend (port 3000)
- Updated backend index.ts to prefix all routes with /api
- Files changed:
  - packages/frontend/src/components/Board.tsx (new file)
  - packages/frontend/src/components/Board.css (new file)
  - packages/frontend/src/App.tsx (replaced with Board component)
  - packages/frontend/src/App.css (simplified to full-page layout)
  - packages/frontend/src/index.css (updated with clean design system)
  - packages/frontend/vite.config.ts (added proxy config)
  - packages/backend/src/index.ts (added /api prefix to routes)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Frontend uses fetch() with credentials: 'include' to send JWT cookies to backend
  - Vite proxy config forwards /api requests to backend (http://localhost:3000)
  - Backend routes now prefixed with /api for cleaner separation
  - Board component displays empty state when columns have no tasks
  - Column layout uses flex with fixed 300px width per column
  - Task placeholder cards shown (will be replaced by actual TaskCard component next)
  - Column types: 'goals', 'inbox', 'today', 'wait', 'finished', 'someday'
  - Today column shows count/limit badge (X/3)
---
## Iteration 11 - Build task card component with tags, priority, due date, assignees
- Created TaskCard component displaying all task metadata in card format
- Implemented priority indicator (colored dot with 4 priority levels)
- Added tag display with max 2 visible tags and "+N" overflow indicator
- Created assignee avatars with initials (stacked, max 3 visible)
- Implemented due date formatting with relative dates (today, tomorrow, Xd, overdue)
- Integrated TaskCard into Board component, replacing placeholder cards
- Files changed:
  - packages/frontend/src/components/TaskCard.tsx (new file)
  - packages/frontend/src/components/TaskCard.css (new file)
  - packages/frontend/src/components/Board.tsx (import and use TaskCard)
  - packages/frontend/src/components/Board.css (removed placeholder styles)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Priority colors: hot=#dc2626 (red), warm=#f59e0b (orange), normal=#6b7280 (gray), cold=#3b82f6 (blue)
  - Tag display pattern: Show first 2 tags, then "+N" indicator for remaining tags
  - Assignee display pattern: Show first 3 avatars with 2-letter initials, then "+N" for remaining
  - Due date formatting: Overdue shows "Xd ago" in red, today/tomorrow special labels, then relative days, then absolute date
  - Card hover effect: border color changes to blue with shadow for better UX
  - Task card cursor is pointer to indicate clickable (for future task detail modal)
  - Assignee avatars are stacked with negative margin-left (-8px) for compact display
---
## Iteration 12 - Implement task detail modal/drawer
- Created TaskDetailModal component that displays full task details in a modal overlay
- Modal shows task title, description, priority, due date, tags, and assignees
- Implemented modal close behavior via Escape key and clicking outside
- Added placeholder sections for comments and attachments (to be implemented in M4)
- Updated TaskCard to accept onClick handler and trigger modal
- Updated Board component to manage modal state and display selected task
- Files changed:
  - packages/frontend/src/components/TaskDetailModal.tsx (new file)
  - packages/frontend/src/components/TaskDetailModal.css (new file)
  - packages/frontend/src/components/TaskCard.tsx (added onClick prop)
  - packages/frontend/src/components/Board.tsx (added modal state and integration)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Modal overlay pattern: Fixed position with rgba background overlay at z-index 1000
  - Modal close handlers: Listen for Escape key and click outside (on overlay, not container)
  - Event listeners cleanup: Always remove listeners in useEffect cleanup function
  - Modal body scrolling: Container has max-height 90vh with overflow-y auto on body
  - Task detail sections: Description, Details (grid), Attachments (placeholder), Comments (placeholder)
  - Details grid: 2-column responsive layout (1 column on mobile < 600px)
  - Priority display: Colored dot + label using same colors as task cards
  - Date formatting: formatDate for due dates, formatDateTime for created/updated timestamps
  - Assignees display: Full list with avatars (not truncated like on cards)
  - Comments and Attachments sections are placeholders showing "No comments yet" / "No attachments"
---
## Iteration 13 - Implement task editing (tags, priority, due date, multi-assignees)
- Added GET /account/members endpoint to fetch all account members for assignee selection
- Transformed TaskDetailModal into an editable form with view/edit modes
- Implemented edit mode with input fields for: title, description, tags (comma-separated), priority (select), due date (date picker), assignees (multi-select checkboxes)
- Added save/cancel buttons with proper state management and validation
- Integrated PATCH /tasks/:id API call to update task data
- Added onTaskUpdated callback to refetch tasks in Board after successful save
- Files changed:
  - packages/backend/src/routes/account.ts (added GET /account/members endpoint)
  - packages/frontend/src/components/TaskDetailModal.tsx (added edit mode, form state, save/cancel handlers)
  - packages/frontend/src/components/TaskDetailModal.css (added form input styles, button styles)
  - packages/frontend/src/components/Board.tsx (passed onTaskUpdated callback to modal)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - GET /account/members pattern: Query users joined with account_members, filtered by current user's account
  - Edit mode toggle: Use isEditing state to conditionally render form inputs vs static displays
  - Form state pattern: Maintain separate edit state variables (editTitle, editDescription, etc.) initialized from task props
  - Tags input: Accept comma-separated string, split/trim/filter on save
  - Multi-assignee selection: Use checkbox list with toggleAssignee helper to add/remove from editAssigneeIds array
  - Cancel behavior: Reset all form state to original task values
  - Escape key in edit mode: First press cancels edit, second press closes modal
  - Save flow: Validate title -> PATCH request -> close edit mode -> trigger onTaskUpdated callback -> close modal
  - CSS for form inputs: Consistent border-radius, focus states with blue border and subtle shadow
  - Button styles: Primary (blue bg), Secondary (gray bg), disabled state (opacity 0.5)
---


## Iteration 14 - Implement drag and drop for tasks across columns
- Created POST /tasks/:id/move endpoint in backend with Today max 3 validation
- Added HTML5 drag and drop support to TaskCard component (draggable with onDragStart/onDragEnd)
- Implemented drag handlers in Board component (handleDragStart, handleDragEnd, handleDragOver, handleDrop)
- Added Today limit error message display (fixed position notification that auto-dismisses after 4s)
- Added visual feedback for dragging (cursor: grab/grabbing, opacity change on active)
- Files changed:
  - packages/backend/src/routes/tasks.ts (added POST /tasks/:id/move endpoint)
  - packages/frontend/src/components/Board.tsx (drag state, handlers, today limit message)
  - packages/frontend/src/components/Board.css (today-limit-message styles with animation)
  - packages/frontend/src/components/TaskCard.tsx (draggable props, drag event handlers)
  - packages/frontend/src/components/TaskCard.css (cursor styles for drag)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - POST /tasks/:id/move validates Today column limit (max 3 tasks) before moving
  - Move endpoint handles position recalculation: shifts tasks in source column up, shifts tasks in target column down
  - Within same column: different logic for moving up vs moving down
  - HTML5 drag and drop pattern: draggable attribute, onDragStart/onDragEnd/onDragOver/onDrop events
  - Drag state tracking: Store draggedTask in state to know what's being dragged
  - Drop handler: Calculate new position (append to end = columnTasks.length), call API, refresh tasks
  - Today limit error: Backend returns code='TODAY_LIMIT_REACHED' for special handling
  - UI message pattern: Fixed position notification with slideDown animation, auto-dismiss with setTimeout
  - Drag visual feedback: cursor grab/grabbing, opacity 0.7 on active drag
  - Tasks are dropped at the end of columns (position = column task count) for simplicity
---

## Iteration 15 - Implement drag and drop reordering within columns
- Enhanced drag and drop to support precise positioning within columns (not just at the end)
- Added drop indicators (blue pulsing line) that show where task will be placed
- Implemented drag-over detection on individual TaskCards to calculate drop position (above/below)
- Added visual feedback: drop indicator appears between tasks based on cursor position
- Enhanced handleDrop to accept targetPosition parameter (previously only dropped at end)
- Files changed:
  - packages/frontend/src/components/Board.tsx (added dropTarget state, handleTaskDragOver, handleTaskDrop handlers)
  - packages/frontend/src/components/Board.css (added .drop-indicator with pulse animation)
  - packages/frontend/src/components/TaskCard.tsx (added onDragOver/onDrop props to interface and JSX)
  - PRD.md (marked task complete, also marked tasks 25-26 as complete since they were done in iteration 14)
- Learnings for future iterations:
  - Drop position calculation: Compare e.clientY to element midpoint (getBoundingClientRect) to determine above/below
  - Drop indicator pattern: Blue 3px line with pulse animation (opacity 0.8 to 0.4) for visual feedback
  - State management: Use dropTarget state {column, position} to track where indicator should appear
  - Event handling: Use stopPropagation on task drag events to prevent column handlers from interfering
  - Position index: Find task index in sorted column tasks, use index for drop-above or index+1 for drop-below
  - Clean up: Reset dropTarget state in handleDragEnd and after successful drop
  - Backend already handles reordering logic in POST /tasks/:id/move endpoint (no backend changes needed)
  - Visual pattern: Wrap TaskCard in div to conditionally render drop indicator before the card
  - End-of-column drop: Show indicator after last task when dropTarget.position === columnTasks.length
---

## Iteration 16 - Implement GET /tasks/:id/comments endpoint
- Created GET /tasks/:id/comments endpoint in new comments route file
- Endpoint fetches all comments for a task with author information
- Verifies user access to task via board membership before returning comments
- Returns comments ordered chronologically (ASC by created_at)
- Files changed:
  - packages/backend/src/routes/comments.ts (new file with GET endpoint)
  - packages/backend/src/index.ts (registered comments routes with /api prefix)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Comments table structure: id, task_id, author_id, body, created_at (from initial schema migration)
  - Comment endpoint pattern: Verify task access via board membership, then fetch comments with JOIN to users
  - Response format: { comments: [{ id, task_id, body, author: { id, name, email }, created_at }] }
  - Comments are ordered ASC by created_at for chronological display (oldest first)
  - Route registration: Use app.use('/api', commentsRoutes) since route already includes full path '/tasks/:id/comments'
  - Task access verification: Same pattern as other task routes - join tasks -> boards -> account_members
---

## Iteration 17 - Implement POST /tasks/:id/comments endpoint
- Created POST /tasks/:id/comments endpoint to create new comments
- Endpoint validates task access via board membership before allowing comment creation
- Validates comment body is non-empty string
- Returns created comment with author information
- Files changed:
  - packages/backend/src/routes/comments.ts (added POST endpoint)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Comment creation pattern: Verify task access -> validate body -> insert comment -> fetch author info -> return comment
  - Body validation: Must be non-empty string after trimming whitespace
  - Response format: { comment: { id, task_id, body, author: { id, name, email }, created_at } }
  - HTTP status codes: 201 for successful creation, 400 for validation errors, 404 for task not found
  - Comment body is trimmed before inserting to remove leading/trailing whitespace
  - Created_at is set to NOW() in database for consistent server-side timestamps
  - Author information is fetched separately after comment insert using userId from auth middleware
---

## Iteration 18 - Build comments UI component
- Integrated comments display and submission into TaskDetailModal component
- Added useEffect to fetch comments when modal opens (GET /api/tasks/:id/comments)
- Created comments list UI with author avatar (initials), name, timestamp, and body
- Created comment composer with textarea and submit button
- Implemented handleSubmitComment function to POST new comments and append to local state
- Added CSS styles for comments list, comment items, and comment composer
- Files changed:
  - packages/frontend/src/components/TaskDetailModal.tsx (added Comment interface, comments state, fetch/submit logic, UI)
  - packages/frontend/src/components/TaskDetailModal.css (added comments styles)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Comments UI pattern: Fetch on mount, display chronologically, composer at bottom
  - Comment display: Avatar with initials (gray background), author name, timestamp, body text
  - Comment composer: Textarea with "Write a comment..." placeholder, "Post Comment" button (disabled when empty)
  - Submit flow: POST comment -> append to local state -> clear textarea -> no full refetch needed
  - Comment avatar uses same getInitials helper as assignee avatars (2-letter initials)
  - Comments list shows "No comments yet" when empty, otherwise renders all comments
  - Comment body uses pre-wrap and word-wrap for proper text formatting with line breaks
  - Comments section positioned after Attachments section in modal layout
  - CSS styling: Light gray background (#f9fafb) for comment items and composer with subtle borders
---

## Iteration 19 - Set up file storage (S3/R2/MinIO)
- Installed @aws-sdk/client-s3, @aws-sdk/s3-request-presigner, multer, and @types/multer packages
- Created src/storage.ts with S3-compatible storage functions
- Created docker-compose.yml with MinIO and PostgreSQL services for local development
- Created setup-storage.ts script to initialize storage bucket
- Updated .env.example with S3 configuration variables (endpoint, region, credentials, bucket name)
- Created STORAGE.md documentation covering local (MinIO) and production (AWS S3/Cloudflare R2) setup
- Files changed:
  - packages/backend/package.json (added storage dependencies, setup-storage script)
  - packages/backend/src/storage.ts (S3 client, upload/download/delete functions)
  - packages/backend/src/setup-storage.ts (bucket initialization script)
  - packages/backend/.env.example (added S3 config variables)
  - packages/backend/STORAGE.md (comprehensive storage setup documentation)
  - docker-compose.yml (added MinIO and PostgreSQL services)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Storage uses AWS SDK v3 (@aws-sdk/client-s3) which works with S3, MinIO, R2 (any S3-compatible service)
  - forcePathStyle: true is required for MinIO compatibility
  - Storage keys generated as: {timestamp}-{random-id}.{ext} using crypto.randomBytes(16)
  - Presigned URLs expire after 1 hour (3600 seconds) for secure downloads
  - MinIO runs on port 9000 (API) and 9001 (web console) with default credentials minioadmin/minioadmin
  - Setup storage bucket with: npm run setup-storage (in backend package)
  - Docker Compose provides both PostgreSQL and MinIO for complete local development environment
  - Storage functions: uploadFile(buffer, storageKey, mimeType), getDownloadUrl(storageKey), deleteFile(storageKey)
  - Environment variables: S3_ENDPOINT, S3_REGION, S3_ACCESS_KEY_ID, S3_SECRET_ACCESS_KEY, S3_BUCKET_NAME
  - Multer will be used for handling multipart/form-data file uploads in attachment endpoints
---

## Iteration 20 - Implement POST /tasks/:id/attachments endpoint
- Created POST /tasks/:id/attachments endpoint for uploading file attachments to tasks
- Endpoint uses multer middleware with memory storage to handle multipart/form-data uploads
- Validates user access to task via board membership before allowing upload
- Uploads file to S3-compatible storage and stores metadata in attachments table
- Returns created attachment with uploader information
- Files changed:
  - packages/backend/src/routes/attachments.ts (new file with POST endpoint)
  - packages/backend/src/index.ts (registered attachments routes)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Multer configuration: Use memoryStorage() with 10MB file size limit for uploads
  - Multer middleware: upload.single('file') for single file upload, access via req.file
  - File upload pattern: Validate access -> generate storage key -> upload to S3 -> insert DB record
  - Attachments table: id, task_id, uploader_id, original_filename, mime_type, size_bytes, storage_key, thumbnail_key, created_at
  - File metadata from multer: req.file.originalname, req.file.mimetype, req.file.size, req.file.buffer
  - Storage key generation: generateStorageKey() creates unique key with timestamp and random ID
  - Response format: { attachment: { ...attachment_fields, uploader: { id, name, email } } }
  - HTTP status codes: 201 for success, 400 for missing file, 404 for task not found, 500 for upload errors
  - Route registration: app.use('/api', attachmentsRoutes) to handle /tasks/:id/attachments path
  - TypeScript fix: Handle req.params.id as string | string[] with Array.isArray check
---

## Iteration 21 - Implement GET /attachments/:id endpoint
- Created GET /attachments/:id endpoint to retrieve attachment metadata and download URL
- Endpoint validates user access to task via board membership before returning attachment data
- Returns attachment metadata including uploader information and presigned download URL
- Files changed:
  - packages/backend/src/routes/attachments.ts (added GET endpoint, imported getDownloadUrl)
  - PRD.md (marked task complete)
- Learnings for future iterations:
  - Attachment retrieval pattern: Verify access via task->board->account_members, then generate presigned URL
  - Response includes: attachment metadata + download_url (presigned, expires in 1 hour) + uploader details
  - Access verification: JOIN attachments -> tasks -> boards -> account_members to check user membership
  - Presigned URL generation: Use getDownloadUrl(storage_key) from storage.ts for secure file access
  - HTTP status codes: 200 for success, 404 for not found, 500 for server errors
  - Response format: { attachment: { ...fields, download_url, uploader: { id, name, email } } }
  - Query includes uploader information (JOIN to users table) for display purposes
  - Presigned URLs expire after 1 hour (configured in storage.ts getDownloadUrl function)
---
